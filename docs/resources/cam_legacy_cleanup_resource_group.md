---
page_title: "visionone_cam_legacy_cleanup_resource_group Resource - visionone"
subcategory: "Azure"
description: |-
  Deletes or archives legacy Resource Group created by CAM Ver1 deployments. The resource automatically detects whether a legacy Resource Group exists before attempting cleanup. Supports archive mode (tagging instead of deletion) to preserve Terraform state storage. Returns cleanup_status = "not_found" if no legacy resources exist.
---

# visionone_cam_legacy_cleanup_resource_group (Resource)

Deletes or archives legacy Resource Group created by CAM Ver1 deployments. The resource automatically detects whether a legacy Resource Group exists before attempting cleanup. Supports archive mode (tagging instead of deletion) to preserve Terraform state storage. Returns `cleanup_status = "not_found"` if no legacy resources exist.

## Use Cases

- **Legacy to Ver2 Migration**: Clean up legacy Resource Groups when migrating to Ver2 management group deployments
- **State Preservation**: Archive Resource Groups (instead of deleting) to preserve Terraform state storage
- **Storage Account Cleanup**: Automatically handles legacy storage accounts within Resource Groups
- **Per-Subscription Cleanup**: Clean up Resource Groups across multiple subscriptions systematically
- **Safe Cleanup**: Detects and prevents deletion when Terraform state files exist
- **Graceful Handling**: Returns "not_found" status if no legacy resources exist (no errors)

## Behavior

- **`terraform apply`**: Detects and deletes or archives legacy Resource Group if it exists, based on configuration
- **`terraform destroy`**: Removes resource from Terraform state only (Azure resources unchanged)
- **Built-In Detection**: Automatically detects whether legacy Resource Group exists before attempting cleanup
- **Archive Mode** (`preserve_state_storage = true`): Tags Resource Group with `V1Archived=true` instead of deleting
- **Delete Mode** (`preserve_state_storage = false`): Actually deletes the Resource Group and all contents
- **State File Protection**: Detects Terraform state files and prevents deletion unless `force_delete = true`
- **Graceful Handling**: If no legacy Resource Group exists, returns `cleanup_status = "not_found"` instead of erroring

## Example Usage

```terraform
# Delete or archive legacy Resource Group from CAM Ver1 deployment
resource "visionone_cam_legacy_cleanup_resource_group" "example" {
  subscription_id        = "12345678-1234-1234-1234-123456789012"
  preserve_state_storage = true  # Archive instead of delete (preserves Terraform state)
  force_delete           = false # Don't delete if state files exist
}
```

### Advanced Usage Examples

<details>
<summary>Multi-Subscription Cleanup with Archive Mode</summary>

```terraform
# Multi-subscription legacy Resource Group cleanup with archive mode
variable "subscription_ids" {
  type = list(string)
  default = [
    "12345678-1234-1234-1234-123456789012",
    "23456789-2345-2345-2345-234567890123",
  ]
}

locals {
  cleanup_subscription_ids = toset(var.subscription_ids)
}

# Cleanup Custom Roles first (dependencies)
resource "visionone_cam_legacy_cleanup_custom_role" "cleanup" {
  for_each = local.cleanup_subscription_ids

  subscription_id = each.value
}

# Deploy Ver2 CAM connector resources (not shown - see CAM connector examples)
# resource "visionone_cam_connector_azure" "subscriptions" {...}

# Cleanup Resource Groups (depends on custom role cleanup)
resource "visionone_cam_legacy_cleanup_resource_group" "cleanup" {
  depends_on = [
    visionone_cam_connector_azure.subscriptions,
    visionone_cam_legacy_cleanup_custom_role.cleanup
  ]

  for_each = local.cleanup_subscription_ids

  subscription_id        = each.key
  preserve_state_storage = true  # Archive instead of delete (preserves Terraform state)
  force_delete           = false # Don't delete if state files exist
}

# Output cleanup results
output "resource_group_cleanup_summary" {
  value = {
    for k, v in visionone_cam_legacy_cleanup_resource_group.cleanup :
    k => {
      deleted            = v.deleted
      archived           = v.archived
      cleanup_status     = v.cleanup_status
      deletion_timestamp = v.deletion_timestamp
    }
  }
}
```

</details>

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `subscription_id` (String) Azure subscription ID containing the legacy Resource Group to delete

### Optional

- `force_delete` (Boolean) If true, delete resource group even if state files exist (ignored if preserve_state_storage is true). Default: false
- `preserve_state_storage` (Boolean) If true, archive the resource group with tags instead of deleting (preserves Terraform state storage). Default: true

### Read-Only

- `archived` (Boolean) Whether the Resource Group was archived (tagged) instead of deleted
- `cleanup_error` (String) Error message if cleanup failed
- `cleanup_status` (String) Status of cleanup operation: deleted, archived, not_found, or failed
- `deleted` (Boolean) Whether the Resource Group was successfully deleted
- `deletion_timestamp` (String) Timestamp when deletion/archiving was performed (RFC3339 format)
- `id` (String) Unique identifier for this cleanup resource (subscription ID)

## Important Notes

- **Built-In Detection**: Resource automatically detects whether legacy Resource Group exists before attempting cleanup
- **Archive vs Delete**: By default (`preserve_state_storage = true`), Resource Groups are archived (tagged) to preserve Terraform state storage
- **State File Safety**: Automatically detects Terraform state files and prevents deletion unless `force_delete = true`
- **Per-Subscription**: Each subscription has its own Resource Group that must be cleaned up separately
- **Storage Account Handling**: Legacy storage accounts within the Resource Group are also affected by cleanup
- **Graceful Handling**: If no legacy Resource Group exists, `cleanup_status` will be "not_found" (not an error)
- **No Dry Run**: This resource always attempts cleanup when applied (gracefully handles non-existent resources)

## Archive vs Delete Decision

### When to Archive (`preserve_state_storage = true`) - **Default**
- Terraform state files exist in the legacy storage account
- Want to preserve historical state for auditing or rollback
- Safer option that doesn't lose data
- Resource Group is tagged with `V1Archived=true` and `V1ArchivedAt=<timestamp>`

### When to Delete (`preserve_state_storage = false`)
- Confirmed no important state files exist
- Want to completely remove all legacy infrastructure
- Ready to permanently remove all resources
- Use with caution - deletion is permanent

## Cleanup Status Values

The `cleanup_status` field indicates what happened:

- **`deleted`** - Legacy Resource Group was found and successfully deleted
- **`archived`** - Legacy Resource Group was found and successfully archived (tagged)
- **`not_found`** - No legacy Resource Group exists (nothing to clean up)
- **`failed`** - Cleanup operation encountered an error (check `cleanup_error` field for details)
- **`recreated`** - Legacy resource was recreated after previous cleanup (detected during refresh)

## Terraform Behavior

### terraform apply
Creates the cleanup resource in Terraform state, detects legacy Resource Group, and deletes or archives it if found.

### terraform destroy
Removes the cleanup resource from Terraform state. **Does NOT delete** the Azure Resource Group (cleanup only happens on apply, not destroy).

### terraform refresh
Re-checks if the Resource Group was recreated after cleanup. Updates `cleanup_status` to "recreated" if detected.

## Import

Legacy cleanup resources do not support import as they are cleanup operations rather than persistent Azure resources.
